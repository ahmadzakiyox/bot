"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuMiddleware = void 0;
const telegraf_1 = require("telegraf");
const path_1 = require("./path");
const send_menu_1 = require("./send-menu");
class MenuMiddleware {
    constructor(rootTrigger, rootMenu, options = {}) {
        var _a;
        Object.defineProperty(this, "rootTrigger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rootTrigger
        });
        Object.defineProperty(this, "rootMenu", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rootMenu
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "_sendMenu", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_responder", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const rootTriggerRegex = path_1.createRootMenuTrigger(rootTrigger);
        this._responder = createResponder(rootTriggerRegex, () => true, rootMenu);
        this._sendMenu = (_a = options.sendMenu) !== null && _a !== void 0 ? _a : send_menu_1.editMenuOnContext;
    }
    /**
     * Send the root menu to the context. Shortcut for `replyMenuToContext(â€¦)`
     * @param context Context where the root menu should be replied to
     * @example
     * const menuMiddleware = new MenuMiddleware('/', menuTemplate)
     * bot.command('start', async ctx => menuMiddleware.replyToContext(ctx))
     */
    async replyToContext(context, path = this.rootTrigger) {
        if (typeof path === 'function') {
            // Happens when a JS User does this as next is the second argument and not a string:
            // ctx.command('start', menuMiddleware.replyToContext)
            throw new TypeError('Do not supply this as a middleware directly. Supply it as a function `ctx => menuMiddleware.replyToContext(ctx)`');
        }
        if (typeof path !== 'string') {
            // Happens when the rootTrigger is a RegExp
            throw new TypeError('You have to specify an absolute path explicitly as a string in the second argument.');
        }
        const { match, responder } = await getLongestMatchMenuResponder(context, path, this._responder);
        if (!match) {
            throw new Error('There is no menu which works with your supplied path: ' + path);
        }
        return send_menu_1.replyMenuToContext(responder.menu, context, path);
    }
    /**
     * The tree structure can be shown for debugging purposes.
     * You can take a look on the menu you created.
     */
    tree() {
        return 'Menu Tree\n' + responderTree(this._responder);
    }
    middleware() {
        const composer = new telegraf_1.Composer();
        const trigger = new RegExp(this._responder.trigger.source, this._responder.trigger.flags);
        // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
        composer.action(trigger, async (context, next) => {
            if (!('data' in context.callbackQuery)) {
                return next();
            }
            const path = context.callbackQuery.data;
            let target = path;
            if (!path.endsWith('/')) {
                const { match, responder } = await getLongestMatchActionResponder(context, path, this._responder);
                if ((match === null || match === void 0 ? void 0 : match[0]) && responder.type === 'action') {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    context.match = match;
                    const afterwardsTarget = await responder.do(context, match[0]);
                    if (typeof afterwardsTarget === 'string' && afterwardsTarget) {
                        target = path_1.combinePath(path, afterwardsTarget);
                    }
                    else if (afterwardsTarget === true) {
                        target = path_1.combinePath(path, '.');
                    }
                    else if (afterwardsTarget === false) {
                        target = undefined;
                    }
                    else {
                        throw new Error('You have to return in your do function if you want to update the menu afterwards or not. If not just use return false.');
                    }
                }
            }
            if (target) {
                const { match, responder } = await getLongestMatchMenuResponder(context, target, this._responder);
                if (!(match === null || match === void 0 ? void 0 : match[0])) {
                    // TODO: think about using next() in this case?
                    throw new Error(`There is no menu "${target}" which can be reached in this menu`);
                }
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                context.match = match;
                const targetPath = match[0];
                await this._sendMenu(responder.menu, context, targetPath);
                await context.answerCbQuery()
                    .catch(catchCallbackOld);
            }
        });
        return composer.middleware();
    }
}
exports.MenuMiddleware = MenuMiddleware;
function catchCallbackOld(error) {
    if (error instanceof Error && error.message.includes('query is too old and response timeout expired')) {
        // ignore
        return;
    }
    throw error;
}
function responderMatch(responder, path) {
    return new RegExp(responder.trigger.source, responder.trigger.flags).exec(path);
}
async function getLongestMatchMenuResponder(context, path, current) {
    for (const sub of current.submenuResponders) {
        const match = responderMatch(sub, path);
        if (!(match === null || match === void 0 ? void 0 : match[0])) {
            continue;
        }
        // Telegraf users expect context.match to contain the relevant match
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        context.match = match;
        // eslint-disable-next-line no-await-in-loop
        if (await sub.canEnter(context, match[0])) {
            return getLongestMatchMenuResponder(context, path, sub);
        }
    }
    const match = responderMatch(current, path);
    return { match, responder: current };
}
async function getLongestMatchActionResponder(context, path, current) {
    const currentMatch = responderMatch(current, path);
    for (const sub of current.submenuResponders) {
        const match = responderMatch(sub, path);
        if (!(match === null || match === void 0 ? void 0 : match[0])) {
            continue;
        }
        // Telegraf users expect context.match to contain the relevant match
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        context.match = match;
        // eslint-disable-next-line no-await-in-loop
        if (await sub.canEnter(context, match[0])) {
            return getLongestMatchActionResponder(context, path, sub);
        }
        return { match: currentMatch, responder: current };
    }
    for (const sub of current.actionResponders) {
        const match = responderMatch(sub, path);
        if (!match) {
            continue;
        }
        return { match, responder: sub };
    }
    return { match: currentMatch, responder: current };
}
function createResponder(menuTrigger, canEnter, menu) {
    const actionResponders = [...menu.renderActionHandlers(menuTrigger)]
        .map(({ trigger, doFunction }) => ({
        type: 'action',
        trigger,
        do: doFunction,
    }));
    const submenuResponders = [...menu.listSubmenus()]
        .map((submenu) => {
        const submenuTrigger = path_1.combineTrigger(menuTrigger, submenu.action);
        const canEnterSubmenu = async (context, path) => {
            var _a;
            if (await ((_a = submenu.hide) === null || _a === void 0 ? void 0 : _a.call(submenu, context, path))) {
                return false;
            }
            return true;
        };
        return createResponder(submenuTrigger, canEnterSubmenu, submenu.menu);
    });
    return {
        type: 'menu',
        trigger: menuTrigger,
        canEnter,
        menu,
        actionResponders,
        submenuResponders,
    };
}
function responderTree(responder, indention = '') {
    let text = treeLine(indention, responder.type, responder.trigger.source);
    const subIndention = '  ' + indention;
    for (const action of responder.actionResponders) {
        text += treeLine(subIndention, action.type, action.trigger.source);
    }
    for (const submenu of responder.submenuResponders) {
        text += responderTree(submenu, subIndention);
    }
    return text;
}
function treeLine(indention, type, regexSource) {
    let text = indention + type;
    const offset = Math.max(1, 30 - text.length);
    for (let i = 0; i < offset; i++) {
        text += ' ';
    }
    text += regexSource
        .replace(/\\\//g, '/')
        .replace(/^\^/, '')
        .replace(/\$$/, '');
    text += '\n';
    return text;
}
//# sourceMappingURL=menu-middleware.js.map