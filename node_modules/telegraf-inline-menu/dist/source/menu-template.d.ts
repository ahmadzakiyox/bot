import { Body } from './body';
import { ButtonAction, ActionFunc } from './action-hive';
import { Choices } from './choices';
import { ChooseOptions } from './buttons/choose';
import { ContextPathFunc, ConstOrContextFunc, ConstOrContextPathFunc, RegExpLike } from './generic-types';
import { ButtonTemplate, ButtonTemplateRow, InlineKeyboard } from './keyboard';
import { MenuLike, Submenu } from './menu-like';
import { PaginationOptions } from './buttons/pagination';
import { SelectOptions } from './buttons/select';
import { SingleButtonOptions } from './buttons/basic';
import { SubmenuOptions, ChooseIntoSubmenuOptions } from './buttons/submenu';
import { ToggleOptions } from './buttons/toggle';
export interface InteractionOptions<Context> extends SingleButtonOptions<Context> {
    /**
     * Function which is called when the button is pressed
     */
    readonly do: ActionFunc<Context>;
}
export declare class MenuTemplate<Context> {
    private readonly _body;
    private readonly _keyboard;
    private readonly _actions;
    private readonly _submenus;
    constructor(body: ConstOrContextPathFunc<Context, Body>);
    /**
     * Creates the message body. Usage only recommended for advanced usage of this library.
     * @param context Context to be supplied to the buttons on on creation
     */
    renderBody(context: Context, path: string): Promise<Body>;
    /**
     * Creates the raw keyboard information. Usage only recommended for advanced usage of this library.
     * @param context Context to be supplied to the buttons on on creation
     * @param path Path within the menu. Will be used for the relativePaths
     */
    renderKeyboard(context: Context, path: string): Promise<InlineKeyboard>;
    /**
     * Creates the actions that the buttons of the template want to happen. Usage only recommended for advanced usage of this library.
     * @param path Path within the menu. Will be used for the relativePaths
     */
    renderActionHandlers(path: RegExpLike): ReadonlySet<ButtonAction<Context>>;
    /**
     * Lists the submenus used in this menu template. Usage only recommended for advanced usage of this library.
     */
    listSubmenus(): ReadonlySet<Submenu<Context>>;
    /**
     * Allows for manual creation of a button in a very raw way of doing. Less user friendly but very customizable.
     * @param button constant or function returning a button representation to be added to the keyboard
     * @param options additional options
     */
    manual(button: ConstOrContextPathFunc<Context, ButtonTemplate>, options?: SingleButtonOptions<Context>): void;
    /**
     * Allows for manual creation of many buttons. Less user friendly but very customizable.
     * @param creator function generating a keyboard part
     */
    manualRow(creator: ContextPathFunc<Context, ButtonTemplateRow[]>): void;
    /**
     * Allows for manual creation of actions. Less user friendly but very customizable.
     * Is probably used together with manualRow.
     * @param trigger regular expression which is appended to the menu path.
     * @param action function which is called when the trigger is matched.
     * @example
     * menuTemplate.manualRow((context, path) => [[{text: 'Page 2', relativePath: 'custom-pagination:2'}, {text: 'Page 3', relativePath: 'custom-pagination:3'}]])
     * menuTemplate.manualAction(/custom-pagination:(\d+)$/, (context, path) => {
     *   console.log('manualAction', path, context.match![1])
     *   return '.'
     * })
     */
    manualAction(trigger: RegExpLike, action: ActionFunc<Context>): void;
    /**
     * Add an url button to the keyboard
     * @param text text to be displayed on the button
     * @param url url where this button should be heading
     * @param options additional options
     */
    url(text: ConstOrContextPathFunc<Context, string>, url: ConstOrContextPathFunc<Context, string>, options?: SingleButtonOptions<Context>): void;
    /**
     * Add a switch_inline_query button to the keyboard
     * @param text text to be displayed on the button
     * @param query query that is shown next to the bot username. Can be empty ('')
     * @param options additional options
     */
    switchToChat(text: ConstOrContextPathFunc<Context, string>, query: ConstOrContextPathFunc<Context, string>, options?: SingleButtonOptions<Context>): void;
    /**
     * Add a switch_inline_query_current_chat button to the keyboard
     * @param text text to be displayed on the button
     * @param query query that is shown next to the bot username. Can be empty ('')
     * @param options additional options
     */
    switchToCurrentChat(text: ConstOrContextPathFunc<Context, string>, query: ConstOrContextPathFunc<Context, string>, options?: SingleButtonOptions<Context>): void;
    /**
     * Button which only purpose is to move around the menu on click.
     * The relative path is inspired by the cd command.
     * If you want to execute a function on click use `menuTemplate.interact(…)` instead.
     * @param text text to be displayed on the button
     * @param relativePath relative target path like 'child/', '..' or '../sibling/
     * @param options additional options
     *
     * @example menuTemplate.navigate('back to parent menu', '..')
     * @example menuTemplate.navigate('to the root menu', '/')
     * @example menuTemplate.navigate('to a sibling menu', '../sibling/')
     */
    navigate(text: ConstOrContextPathFunc<Context, string>, relativePath: string, options?: SingleButtonOptions<Context>): void;
    /**
     * Add a button to which a function is executed on click.
     * You can update the menu afterwards by returning a relative path. If you only want to update the menu or move around use `menuTemplate.navigate(…)` instead.
     * @param text text to be displayed on the button
     * @param action unique identifier for this button within the menu template
     * @param options additional options. Requires `do` as you want to do something when the user pressed the button.
     * @example
     * menuTemplate.interact('Knock Knock', 'unique', {
     *   do: async context => {
     *     await context.answerCbQuery('Who is there?')
     *     return false // Do not update the menu afterwards
     *   }
     * })
     * @example
     * menuTemplate.interact('Update the current menu afterwards', 'unique', {
     *   do: async context => {
     *     // do what you want to do
     *     return '.' // . like the current one -> this menu
     *   }
     * })
     */
    interact(text: ConstOrContextPathFunc<Context, string>, action: string, options: InteractionOptions<Context>): void;
    /**
     * Add a button to a submenu
     * @param text text to be displayed on the button
     * @param action unique identifier for this button within the menu template
     * @param submenu submenu to be entered on click
     * @param options additional options
     * @example
     * const submenuTemplate = new MenuTemplate('I am a submenu')
     * submenuTemplate.interact('Text', 'unique', {
     *   do: async ctx => ctx.answerCbQuery('You hit a button in a submenu')
     * })
     * submenuTemplate.manualRow(createBackMainMenuButtons())
     *
     * menuTemplate.submenu('enter submenu', 'unique', submenuTemplate)
     */
    submenu(text: ConstOrContextPathFunc<Context, string>, action: string, submenu: MenuLike<Context>, options?: SubmenuOptions<Context>): void;
    /**
     * Let the user choose one of many options and execute a function for the one the user picked
     * @param actionPrefix prefix which is used to create a unique identifier for each of the resulting buttons
     * @param choices choices the user can pick from
     * @param options additional options. Requires `do` as you want to do something when the user pressed a button.
     */
    choose(actionPrefix: string, choices: ConstOrContextFunc<Context, Choices>, options: ChooseOptions<Context>): void;
    /**
     * Submenu which is entered when a user picks one of many choices
     * @param actionPrefix prefix which is used to create a unique identifier for each of the resulting buttons
     * @param choices choices the user can pick from. Also see `menuTemplate.choose(…)` for examples on choices
     * @param submenu submenu to be entered when one of the choices is picked
     * @param options additional options
     * @example
     * const submenu = new MenuTemplate<MyContext>(ctx => `Welcome to ${ctx.match[1]}`)
     * submenu.interact('Text', 'unique', {
     *   do: async ctx => {
     *     console.log('Take a look at ctx.match. It contains the chosen city', ctx.match)
     *     await ctx.answerCbQuery('You hit a button in a submenu')
     *     return false
     *   }
     * })
     * submenu.manualRow(createBackMainMenuButtons())
     *
     * menu.chooseIntoSubmenu('unique', ['Gotham', 'Mos Eisley', 'Springfield'], submenu)
     */
    chooseIntoSubmenu(actionPrefix: string, choices: ConstOrContextFunc<Context, Choices>, submenu: MenuLike<Context>, options?: ChooseIntoSubmenuOptions<Context>): void;
    /**
     * Let the user select one (or multiple) options from a set of choices
     * @param actionPrefix prefix which is used to create a unique identifier for each of the resulting buttons
     * @param choices choices the user can pick from. Also see `menuTemplate.choose(…)` for examples on choices
     * @param options additional options. Requires `set` and `isSet`.
     * @example
     * // User can select exactly one
     * menuTemplate.select('unique', ['at home', 'at work', 'somewhere else'], {
     *   isSet: (context, key) => context.session.currentLocation === key,
     *   set: (context, key) => {
     *     context.session.currentLocation = key
     *     return true
     *   }
     * })
     * @example
     * // User can select one of multiple options
     * menuTemplate.select('unique', ['has arms', 'has legs', 'has eyes', 'has wings'], {
     *   showFalseEmoji: true,
     *   isSet: (context, key) => Boolean(context.session.bodyparts[key]),
     *   set: (context, key, newState) => {
     *     context.session.bodyparts[key] = newState
     *     return true
     *   }
     * })
     */
    select(actionPrefix: string, choices: ConstOrContextFunc<Context, Choices>, options: SelectOptions<Context>): void;
    /**
     * Shows a row of pagination buttons.
     * When the user presses one of the buttons `setPage` is called with the specified button.
     * In order to determine which is the current page and how many pages there are `getCurrentPage` and `getTotalPages` are called to which you have to return the current value
     * @param actionPrefix prefix which is used to create a unique identifier for each of the resulting buttons
     * @param options additional options. Requires `getCurrentPage`, `getTotalPages` and `setPage`.
     */
    pagination(actionPrefix: string, options: PaginationOptions<Context>): void;
    /**
     * Toogle a value when the button is pressed.
     * If you want to toggle multiple values use `menuTemplate.select(…)`
     * @param text text to be displayed on the button
     * @param actionPrefix unique identifier for this button within the menu template
     * @param options additional options. Requires `set` and `isSet`.
     * @example
     * menuTemplate.toggle('Text', 'unique', {
     *   isSet: context => Boolean(context.session.isFunny),
     *   set: (context, newState) => {
     *     context.session.isFunny = newState
     *     return true
     *   }
     * })
     * @example
     * // You can use a custom format for the state instead of the default emoji
     * menuTemplate.toggle('Lamp', 'unique', {
     *   formatState: (context, text, state) => `${text}: ${state ? 'on' : 'off'}`,
     *   isSet: context => Boolean(context.session.lamp),
     *   set: (context, newState) => {
     *     context.session.lamp = newState
     *     return true
     *   }
     * })
     */
    toggle(text: ConstOrContextPathFunc<Context, string>, actionPrefix: string, options: ToggleOptions<Context>): void;
}
